<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loading...</title>
  <link href="/output.css" rel="stylesheet">
  <link rel="stylesheet" href="https://use.typekit.net/bne3zga.css">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <style>
    body {
      font-optical-sizing: auto;
      font-style: normal;
      background-color: white;
      overflow-y: auto;
    }

    /* prevent layout loading from anchoring scroll (avoid jumps when images load) */
    #content-container {
      overflow-anchor: none;
    }

    h1 {
      font-size: 3rem;
      line-height: 1.1;
      margin-bottom: 1rem;
    }

    img {
      margin: 0 auto;
      opacity: 0;
      animation: fadeIn 1s ease-in-out forwards;
    }

    .first-img-cover>img:first-of-type,
    .first-img-cover>figure:first-of-type>img {
      width: 100%;
      min-height: 100vh;
      object-fit: cover;
    }

    /* Define the fade-in keyframe animation */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .masonry-container {
      margin: 20px;
      column-count: 2;
      column-gap: 1rem;
    }
    /* ability to have 1 column on mobile */
    .masonry-container.masonry-mobile-1 {
      column-count: 1;
    }

    @media (min-width: 768px) {
      .masonry-container {
        column-count: 4;
      }

      .masonry-container.masonry-2 {
        column-count: 2;
      }

      .masonry-container.masonry-3 {
        column-count: 3;
      }

      .masonry-container.masonry-4 {
        column-count: 4;
      }

      .masonry-container.masonry-6 {
        column-count: 5;
      }
    }

    .masonry-container img {
      width: 100%;
      display: block;
      margin-bottom: 1rem;
      break-inside: avoid;
    }

    figure {
      position: relative;
    }

    figure figcaption {
      position: absolute;
      bottom: 15px;
      width: 100%;
      margin: 0;
      font-size: 2rem;
      text-align: center;
      color: white;
    }

    figure figcaption.caption-center {
      left: 50%;
      bottom: 50%;
      transform: translate(-50%, 50%);
    }

    @media (max-width: 767px) {
      figure figcaption {
        font-size: 1.5rem;
      }
    }

    main img {
      margin-bottom: 0.5rem;
    }

    div.sidescroll-gallery {
      height: 100vh;
      display: flex;
      overflow-x: auto;
      gap: 1rem;
      scroll-snap-type: x mandatory;
      /* Optional: enables snap scrolling */
      -webkit-overflow-scrolling: touch;
      /* For smooth scrolling on iOS */
      scrollbar-width: none;
      /* For Firefox */
    }

    div.sidescroll-gallery img {
      height: 100vh;
      width: auto;
      /* let width scale naturally (keeping aspect ratio) */
      max-width: none;
      /* prevent max-width skewing images */
      flex-shrink: 0;
      /* prevent images from shrinking */
      scroll-snap-align: start;
    }

    div.sidescroll-gallery div {
      min-width: 300px;
      height: 100vh;
      padding-top: 88px;
      box-sizing: border-box;
    }

    div.sidescroll-gallery::-webkit-scrollbar {
      display: none;
      /* For Chrome, Safari, Opera */
    }
  </style>
</head>

<body class="relative min-h-screen">
  <!-- Navigation Menu -->
  <nav class="absolute top-0 left-0 w-full z-10 p-4 bg-transparent">
    <div id="logo" class="container mx-auto flex justify-between items-center px-4 md:px-0">
      <a href="/" id="logo-link" class="font-ambroise text-4xl font-bold text-white rounded-md p-2">
        <!-- manifest.logo will be injected -->
      </a>
      <!-- Hamburger button (shown on mobile) -->
      <button id="hamburger-btn" class="md:hidden text-white text-5xl focus:outline-none" aria-label="Open menu">
        &equiv;
      </button>
      <!-- Desktop nav links -->
      <div class="space-x-4 hidden md:block" id="nav-links"></div>
    </div>
    <!-- Mobile overlay menu -->
    <div id="mobile-nav-overlay"
      class="fixed inset-0 bg-black bg-opacity-90 flex flex-col justify-center items-center z-50 hidden">
      <button id="close-mobile-nav" class="absolute top-6 right-8 text-white text-4xl">
        &#10005;
      </button>
      <nav id="mobile-nav-list" class="flex flex-col space-y-8 text-center text-3xl font-bold"></nav>
    </div>
  </nav>

  <!-- Main content container -->
  <main id="content-container" class="relative w-full h-screen">
    <!-- Content will be dynamically injected here -->
  </main>

  <script>

    const isDev = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
    let GA_TRACKING_ID = null; // will be set from manifest.meta.ga if present

    // Function to track a pageview for the new route
    function trackPageView(path, title) {
      if (typeof gtag === 'function') {
        gtag('event', 'page_view', {
          page_title: title,
          page_path: path,
          send_to: GA_TRACKING_ID
        });
        console.log(`GA: Path=${path}, Title=${title}`);
      }
    }

    function submitForm(formElem, intent) {
      try {
        const payload = { intent, checkboxes: {} };
        const fd = new FormData(formElem);
        
        // Collect form entries
        for (const [key, value] of fd.entries()) {
            // For checked checkboxes, key will be the unique name (e.g., 'option_1'), 
            // and value will be its 'value' attribute (e.g., 'on' or a specific ID).
            if (payload[key] === undefined) payload[key] = value;
            // The array logic is still useful for multi-selects or other same-named fields, 
            // but less likely to be hit by uniquely named checkboxes.
            else if (Array.isArray(payload[key])) payload[key].push(value); 
            else payload[key] = [payload[key], value];
        }
        // 2. Manually process checkboxes to capture the true/false state
        formElem.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            // Use the UNIQUE NAME as the key in the payload
            if (cb.name) {
                payload['checkboxes'][cb.name] = cb.checked;
            }
        });

        fetch('/form', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
          .then(res => {
            if (res.ok) {
              formElem.reset();
            } else {
              console.warn('Sorry, something went wrong at /', intent);
            }
          })
          .catch(() => console.error('Network error â€” please try again.'));
      } catch (err) {
        console.error('submitForm error', err);
      }
    }

    /* prevent layout loading from anchoring scroll (avoid jumps when images load) */
    if ('scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }

    function scrollToTopNow() {
      // reset scrolling on document and the main container
      window.scrollTo(0, 0);
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      const container = document.getElementById('content-container');
      if (container) container.scrollTop = 0;
      // double rAF to ensure after paint/layout
      requestAnimationFrame(() => requestAnimationFrame(() => window.scrollTo(0, 0)));
    }

    fetch('/api/manifest')
      .then(res => {
        if (!res.ok) throw new Error('Failed to load manifest');
        return res.json();
      })
      .then(manifestData => {
        // server returned merged manifest and included raw folder as _folder
        window.manifest = manifestData;

        // set document title from manifest.meta.title (if present)
        if (manifestData.meta && manifestData.meta.title) {
          document.title = manifestData.meta.title;
        }

        if (manifestData.meta && manifestData.meta.robots) {
          // create or update <meta name="robots" content="...">
          const existing = document.querySelector('meta[name="robots"]');
          if (existing) {
            existing.content = manifestData.meta.robots;
          } else {
            const m = document.createElement('meta');
            m.name = 'robots';
            m.content = manifestData.meta.robots;
            document.head.appendChild(m);
          }
        }

        // set logo (text or simple HTML) from manifest.meta.logo
        const logoLink = document.getElementById('logo-link');
        if (logoLink) {
          const logoContent = (manifestData.meta && manifestData.meta.logo) ? manifestData.meta.logo : '';
          logoLink.innerHTML = logoContent;
        }

        // build nav links (desktop and mobile) from manifest.nav
        const buildNav = (navArray) => {
          const desktop = document.getElementById('nav-links');
          const mobile = document.getElementById('mobile-nav-list');
          if (desktop) desktop.innerHTML = '';
          if (mobile) mobile.innerHTML = '';
          (navArray || []).forEach(item => {
            const a = document.createElement('a');
            a.href = item.href || '/';
            a.textContent = item.label || item.href;
            a.className = 'px-2';
            if (desktop) desktop.appendChild(a);
            const am = a.cloneNode(true);
            if (mobile) mobile.appendChild(am);
          });
        };
        if (manifestData.nav) buildNav(manifestData.nav);

        // set footer from manifest.footer (if present)
        if (manifestData.footer) {
          const footerElem = document.querySelector('footer');
          if (footerElem) {
            footerElem.innerHTML = manifestData.footer;
          }
        }

        // attach mobile nav handlers
        (function setupMobileHandlers() {
          const hamburgerBtn = document.getElementById("hamburger-btn");
          const mobileNavOverlay = document.getElementById("mobile-nav-overlay");
          const closeMobileNav = document.getElementById("close-mobile-nav");
          const mobileNavLinks = mobileNavOverlay.querySelectorAll("a");
          if (hamburgerBtn && mobileNavOverlay) {
            hamburgerBtn.addEventListener("click", () => mobileNavOverlay.classList.remove("hidden"));
          }
          if (closeMobileNav && mobileNavOverlay) {
            closeMobileNav.addEventListener("click", () => mobileNavOverlay.classList.add("hidden"));
          }
          mobileNavLinks.forEach((link) => {
            link.addEventListener("click", () => mobileNavOverlay.classList.add("hidden"));
          });
        })();

        // dynamically load Google Analytics if provided
        if (manifestData.meta && manifestData.meta.ga) {
          GA_TRACKING_ID = manifestData.meta.ga;
          // inject gtag script
          const gtagScript = document.createElement('script');
          gtagScript.async = true;
          gtagScript.src = `https://www.googletagmanager.com/gtag/js?id=${GA_TRACKING_ID}`;
          document.head.appendChild(gtagScript);
          // inject initialization
          const inline = document.createElement('script');
          inline.text = `
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', '${GA_TRACKING_ID}');
            `;
          document.head.appendChild(inline);
        }

        // inject project-specific CSS files
        (manifest.css || []).forEach(href => {
          const l = document.createElement('link');
          l.rel = 'stylesheet';
          l.href = href;
          document.head.appendChild(l);
        });
        // inject font stylesheet links (e.g. Google Fonts)
        (manifest.fonts || []).forEach(href => {
          const l = document.createElement('link');
          l.rel = 'stylesheet';
          l.href = href;
          document.head.appendChild(l);
        });
        // render DOM
        renderPage();
      })
      .catch(err => {
        console.error('Error loading manifest:', err);
      });

    const contentContainer = document.getElementById("content-container");
    const desktopMediaQuery = window.matchMedia("(min-width: 768px)");


    function getImageSrc(filename) {
      // Use window.location.hostname to detect environment
      if (isDev) {
        return `/img/${filename}`;
      } else {
        return `https://res.cloudinary.com/dg7vg50i9/image/upload/f_auto,q_auto/${filename}`;
      }
    }


    function renderTree(node) {
      if (!node) return "";

      // cross-reference folder.json for source arrays
      if (node.source) {
        node.children = window?.manifest?._folder?.flat[node.source]
          ?.map(img => ({
            type: "img",
            src: `${node.source}/${img}`,
            alt: img,
          }))
          // shuffle the array
          .map(value => ({ value, sort: Math.random() }))
          .sort((a, b) => a.sort - b.sort)
          .map(({ value }) => value) || [];
      }

      if (node.type === undefined) node.type = "div";

      // handle text nodes quickly
      if (node.type === "text") return node.content || "";

      // inject meta summary into children if present
      if (node.meta) {
        node?.children?.splice(1, 0, {
          type: "div",
          class: "m-[20px] text-2xl font-eb-garamond text-black mx-auto text-left max-w-[70%]",
          content: node.meta
        });
      }

      // BACKGROUND node handling (unchanged)
      if (node.type === "background") {
        const bgImage = getImageSrc(node.src);
        let extraStyle = `background-image: url(${bgImage}); background-size: cover; background-position: center;`;
        extraStyle += "width: 100%; height: 100vh;";
        const classProp = node.class ? ` class="${node.class}"` : "";
        const styleProp = ` style="${extraStyle}"`;
        let childrenStr = "";
        if (node.children && Array.isArray(node.children)) {
          childrenStr = node.children.map(renderTree).join("");
        }
        return `<div${classProp}${styleProp}>${node.content || ""}${childrenStr}</div>`;
      }

      // EXPLICIT INPUT handling: checkbox, radio, text, submit, etc.
      if (node.type === "input") {
        const type = node.typeAttr || "text";
        const attrs = [];
        attrs.push(`type="${type}"`);
        if (node.name) attrs.push(`name="${node.name}"`);
        if (node.value !== undefined) attrs.push(`value="${node.value}"`);
        if (node.placeholder) attrs.push(`placeholder="${node.placeholder}"`);
        if (node.class) attrs.push(`class="${node.class}"`);
        if (node.id) attrs.push(`id="${node.id}"`);
        if (node.required) attrs.push(`required`);
        if (node.checked) attrs.push(`checked`);
        // Any other string attributes
        const reserved = ["type", "children", "content", "class", "style", "src", "alt", "meta", "caption", "captionStyle", "linkTo", "source", "typeAttr"];
        Object.keys(node).forEach((k) => {
          if (!reserved.includes(k) && typeof node[k] === "string") {
            attrs.push(`${k}="${node[k]}"`);
          }
        });
        return `<input ${attrs.join(" ")}/>`;
      }

      // SELECT + OPTION handling
      if (node.type === "select") {
        const attrs = [];
        if (node.name) attrs.push(`name="${node.name}"`);
        if (node.class) attrs.push(`class="${node.class}"`);
        if (node.multiple) attrs.push(`multiple`);
        if (node.id) attrs.push(`id="${node.id}"`);
        // build options
        let optionsHtml = "";
        const children = node.children || [];
        children.forEach(opt => {
          if (opt.type === "option") {
            const val = opt.value !== undefined ? opt.value : (opt.content || "");
            const selected = node.value !== undefined && String(node.value) === String(val) ? ' selected' : (opt.selected ? ' selected' : '');
            const optClass = opt.class ? ` class="${opt.class}"` : '';
            optionsHtml += `<option value="${val}"${selected}${optClass}>${opt.content || val}</option>`;
          }
        });
        return `<select ${attrs.join(" ")}>${optionsHtml}</select>`;
      }

      // For images keep existing behavior
      if (node.type === "img") {
        let imgProps = [];
        if (node.src) {
          if (typeof node.src === "string") {
            imgProps.push(`src="${getImageSrc(node.src)}"`);
          } else if (Array.isArray(node.src)) {
            let randomSrc = node.src[Math.floor(Math.random() * node.src.length)];
            imgProps.push(`src="${getImageSrc(randomSrc)}"`);
          }
        } else {
          console.warn("Image node missing 'src' property:", node);
        }
        if (node.alt) imgProps.push(`alt="${node.alt}"`);
        if (node.class) imgProps.push(`class="${node.class}"`);
        imgProps.push(`loading="lazy"`);
        const reservedImg = ["type", "children", "content", "class", "style", "src", "alt", "caption", "captionStyle"];
        Object.keys(node).forEach(key => {
          if (!reservedImg.includes(key) && typeof node[key] === "string") {
            imgProps.push(`${key}="${node[key]}"`);
          }
        });
        let imageHTML = "";
        if (node.caption) {
          let figCaptionProps = node.captionStyle ? ` class="${node.captionStyle}"` : "";
          imageHTML = `<figure><img ${imgProps.join(" ")}/><figcaption${figCaptionProps}>${node.caption}</figcaption></figure>`;
        } else {
          imageHTML = `<img ${imgProps.join(" ")}/>`;
        }
        if (node.linkTo) {
          imageHTML = `<a href="/${node.linkTo}">${imageHTML}</a>`;
        }
        return imageHTML;
      }

      // Build props string for generic elements
      let propsArr = [];
      if (node.class) propsArr.push(`class="${node.class}"`);

      let styleObj = {};
      if (node.style) {
        const isDesktop = window.matchMedia("(min-width: 768px)").matches;
        if (node.style.desktop || node.style.mobile) {
          styleObj = isDesktop ? node.style.desktop || {} : node.style.mobile || {};
        } else {
          styleObj = node.style;
        }
      }
      if (node.textColor) styleObj = { ...styleObj, color: node.textColor };
      const styleStr = Object.entries(styleObj).map(([k, v]) => `${k}:${v}`).join(";");
      if (styleStr) propsArr.push(`style="${styleStr}"`);

      // other attributes (href, id, name, etc)
      const reserved = ["type", "children", "content", "class", "style", "src", "alt", "caption", "captionStyle", "typeAttr"];
      Object.keys(node).forEach((key) => {
        if (!reserved.includes(key) && typeof node[key] === "string") {
          propsArr.push(`${key}="${node[key]}"`);
        }
      });

      const propsStr = propsArr.length ? " " + propsArr.join(" ") : "";

      // children
      let childrenStr = "";
      if (node.children && Array.isArray(node.children)) {
        childrenStr = node.children.map(renderTree).join("");
      }

      const selfClosing = ["img", "br", "hr", "input", "meta", "link"];
      if (selfClosing.includes(node.type)) {
        return `<${node.type}${propsStr}/>`;
      }

      return `<${node.type}${propsStr}>${node.content || ""}${childrenStr}</${node.type}>`;
    }

    /**
     * Renders the page content based on the current URL hash.
     */
    function renderPage() {

      if (!window.manifest) {
        console.warn("Manifest not loaded yet.");
        return;
      }

      const fullPath = window.location.pathname;
      let currentSlug = fullPath === "/" ? "" : fullPath.slice(1);

      // Try to find an exact match first.
      let currentPage = manifest.pages.find(page => page.slug === currentSlug);

      // If not found and there are subroutes, try to fall back to a parent route.
      if (!currentPage && currentSlug.includes("/")) {
        const segments = currentSlug.split("/");
        while (segments.length > 0 && !currentPage) {
          const routeToCheck = segments.join("/");
          currentPage = manifest.pages.find(page => page.slug === routeToCheck);
          segments.pop();
        }
      }

      // If still not found, redirect to home.
      if (!currentPage) {
        history.replaceState({}, "", "/");
        renderPage();
        return;
      }


      contentContainer.innerHTML = "";
      contentContainer.className = "relative w-full min-h-screen";

      if (currentPage.background) {
        contentContainer.style.backgroundImage = `url(${getImageSrc(currentPage.background)})`;
        contentContainer.style.backgroundSize = "cover";
        contentContainer.style.backgroundPosition = "center";
        contentContainer.style.backgroundAttachment = "fixed";
      } else {
        contentContainer.style.backgroundImage = "";
      }

      // Nav color logic
      const navLinks = document.querySelectorAll("#nav-links a");
      const logo = document.querySelectorAll("#logo a")[0];
      const hamburgerBtn = document.getElementById("hamburger-btn");
      const closeMobileNav = document.getElementById("close-mobile-nav");

      navLinks.forEach((link) => {
        // Reset color and underline
        link.style.color = "";
        link.style.textDecoration = "";
        // Get slug from href
        const linkSlug = link.getAttribute("href").slice(1);
        // If navColor is set, apply it
        if (currentPage.navColor) {
          link.style.color = currentPage.navColor;
          logo.style.color = currentPage.navColor;
          hamburgerBtn.style.color = currentPage.navColor;
          closeMobileNav.style.color = currentPage.navColor;
        } else {
          link.style.color = "";
          logo.style.color = "";
          hamburgerBtn.style.color = "";
          closeMobileNav.style.color = "";
        }
        // Underline active link
        if (linkSlug === currentSlug) {
          link.style.textDecoration = "underline";
        }
      });

      // Render the tree recursively
      contentContainer.innerHTML = renderTree(currentPage.tree);
      // force initial scroll to top immediately after injecting content
      scrollToTopNow();
    }

    // Hook into History API for navigation:
    document.addEventListener("click", function (e) {
      const target = e.target.closest("a");
      if (!target) return;
      const href = target.getAttribute("href");
      if (href && href.startsWith("/")) { // internal link
        e.preventDefault();
        history.pushState({}, "", href);
        if (!isDev) {
          trackPageView(href, href);
        }
        renderPage();
      }
    });

    // Listen for browser back/forward events:
    window.addEventListener("popstate", renderPage);

    // Initial rendering:
    document.addEventListener("DOMContentLoaded", renderPage);

  </script>


  <footer class="text-left p-4 bg-black text-sm text-neutral-500">

  </footer>

</body>

</html>
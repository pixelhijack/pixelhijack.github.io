<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Photography Portfolio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://use.typekit.net/bne3zga.css">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <!--link
      href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap"
      rel="stylesheet"
    /-->
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <!-- link href="https://fonts.cdnfonts.com/css/modernline-personal-use" rel="stylesheet" -->
    <link href="https://fonts.cdnfonts.com/css/reenie-beanie" rel="stylesheet">

    <style>
      /*
        Ambroise Std Regular
            font-family: "ambroise-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Italic
            font-family: "ambroise-std", serif;
            font-weight: 400;
            font-style: italic;
        Ambroise Std Bold
            font-family: "ambroise-std", serif;
            font-weight: 700;
            font-style: normal;
        Ambroise Std Bold Italic
            font-family: "ambroise-std", serif;
            font-weight: 700;
            font-style: italic;
        Ambroise Std Firmin Regular
            font-family: "ambroise-firmin-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Firmin Bold
            font-family: "ambroise-firmin-std", serif;
            font-weight: 700;
            font-style: normal;
        Ambroise Std Francois Regular
            font-family: "ambroise-francois-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Francois Bold
            font-family: "ambroise-francois-std", serif;
            font-weight: 700;
            font-style: normal;
      */
      body {
        font-family: "Josefin Sans", sans-serif;
        font-optical-sizing: auto;
        letter-spacing: -0.05em;
        font-weight: 700;
        font-style: normal;
        background-color: white;
        color: #f5f5f5;
        overflow-y: auto;
      }
      .font-eb-garamond, 
      .font-josefin-sans, 
      .font-ambroise, 
      .font-modernline {
        filter: blur(0.4px);
      }
      .font-eb-garamond {
        font-family: "EB Garamond", serif;
        font-optical-sizing: auto;
        font-weight: 400;
        font-style: normal;
      }
      .font-josefin-sans {
        font-family: "Josefin Sans", sans-serif;
        font-optical-sizing: auto;
        font-weight: 100;
        font-style: normal;
      }
      .font-ambroise {
        font-family: "ambroise-firmin-std", serif;
        font-style: normal;
        font-weight: 400;
      }
      .font-modernline {
        font-family: 'modernline - Personal Use', sans-serif;
        font-style: normal;
        font-weight: 100;
      }
      .font-reenie {
        font-family: 'Reenie Beanie', sans-serif;
        font-style: normal;
        font-weight: 100;
      }
      img {
        margin: 0 auto;
        opacity: 0;
        animation: fadeIn 1s ease-in-out forwards;
      }

      .first-img-cover > img:first-of-type,
      .first-img-cover > figure:first-of-type > img {
        width: 100%;
        min-height: 100vh;
        object-fit: cover;
      }

      /* Define the fade-in keyframe animation */
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .masonry-container {
        margin: 20px;
        column-count: 2;
        column-gap: 1rem;
      }
      @media (min-width: 768px) {
        .masonry-container {
          column-count: 4;
        }
        .masonry-container.masonry-2 { column-count: 2; }
        .masonry-container.masonry-3 { column-count: 3; }
        .masonry-container.masonry-4 { column-count: 4; }
        .masonry-container.masonry-6 { column-count: 5; }
      }
      .masonry-container img {
        width: 100%;
        display: block;
        margin-bottom: 1rem;
        break-inside: avoid;
      }
      figure {
        position: relative;
      }
      figure figcaption {
        position: absolute;
        bottom: 15px;
        width: 100%;
        margin: 0;
        font-size: 2rem;
        text-align: center;
        color: white;
      }
      figure figcaption.caption-center {
        left: 50%;
        bottom: 50%;
        transform: translate(-50%, 50%);
      }
      @media (max-width: 767px) {
        figure figcaption {
          font-size: 1.5rem; 
        }
      }
      main img {
        margin-bottom: 0.5rem;
      }

      div.sidescroll-gallery {
        height: 100vh; 
        display: flex; 
        overflow-x: auto;
        gap: 1rem;
        scroll-snap-type: x mandatory;  /* Optional: enables snap scrolling */
        -webkit-overflow-scrolling: touch; /* For smooth scrolling on iOS */
        scrollbar-width: none;     /* For Firefox */
      }
      div.sidescroll-gallery img {
        height: 100vh;
        width: auto;        /* let width scale naturally (keeping aspect ratio) */
        max-width: none;    /* prevent max-width skewing images */
        flex-shrink: 0;     /* prevent images from shrinking */
        scroll-snap-align: start; 
      }
      div.sidescroll-gallery div {
        min-width: 300px;
        height: 100vh;
        padding-top: 88px;
        box-sizing: border-box;
      }
      div.sidescroll-gallery::-webkit-scrollbar {
        display: none;   /* For Chrome, Safari, Opera */
      }
    </style>
  </head>
  <body class="relative min-h-screen">
    <!-- Navigation Menu -->
    <nav class="absolute top-0 left-0 w-full z-10 p-4 bg-transparent">
      <div
        id="logo"
        class="container mx-auto flex justify-between items-center px-4 md:px-0"
      >
        <a
          href="/"
          class="font-ambroise text-4xl font-bold text-white rounded-md p-2"
        >
          Póth Attila
        </a>
        <!-- Hamburger button (shown on mobile) -->
        <button
          id="hamburger-btn"
          class="md:hidden text-white text-5xl focus:outline-none"
          aria-label="Open menu"
        >
          &equiv;
        </button>
        <!-- Desktop nav links -->
        <div class="space-x-4 hidden md:block" id="nav-links">
          <a href="/fashion">Fashion</a>
          <a href="/analog">Analog</a>
          <a href="/people">People</a>
          <a href="/stories">Stories</a>
          <a href="/backstage">Backstage</a>
          <a href="/projects">Projects</a>
          <a href="/prints">Prints</a>
          <a href="/about">About</a>
        </div>
      </div>
      <!-- Mobile overlay menu -->
      <div
        id="mobile-nav-overlay"
        class="fixed inset-0 bg-black bg-opacity-90 flex flex-col justify-center items-center z-50 hidden"
      >
        <button
          id="close-mobile-nav"
          class="absolute top-6 right-8 text-white text-4xl"
        >
          &#10005;
        </button>
        <nav class="flex flex-col space-y-8 text-center text-3xl font-bold">
          <a href="/fashion">Fashion</a>
          <a href="/analog">Analog</a>
          <a href="/people">People</a>
          <a href="/stories">Stories</a>
          <a href="/backstage">Backstage</a>
          <a href="/projects">Projects</a>
          <a href="/prints">Prints</a>
          <a href="/about">About</a>
        </nav>
      </div>
    </nav>

    <!-- Main content container -->
    <main id="content-container" class="relative w-full h-screen">
      <!-- Content will be dynamically injected here -->
    </main>

    <script>
      const apis = Promise.all([
        fetch("/manifest.json"),
        fetch("/folder.json"),
      ]).then(([manifestRes, folderRes]) =>
        Promise.all([manifestRes.json(), folderRes.json()])
      ).then(([manifestData, folderData]) => {

        Object.keys(folderData.flat).forEach(route => {
          const existingPage = manifestData.pages.find(page => page.slug === route);
          if (existingPage) return; // Skip if page already exists
          manifestData.pages.push({
            slug: route,
            tree: {
              source: route
            }
          });
        });
        manifestData.pages.push({
          "slug": "sitemap",
          "navColor": "white",
          "background": "conceptual/botanic/DSC09953.jpg",
          "tree": {
            "type": "div",
            "class": "pt-[100px] pl-[75px] min-h-screen flex flex-col items-left justify-center space-y-4 p-8",
            "children": [
              {
                "type": "h1",
                "class": "text-4xl md:text-6xl font-ambroise mb-8",
                "content": "Congrats hacker, you found all the pages"
              },
              ...Object.keys(folderData.flat).map(route => ({
                type: "a",
                href: `/${route}`,
                class: "text-1xl md:text-2xl font-bold text-white rounded-md",
                content: route
            }))]
          }
        });

        window.manifest = manifestData;
        window.folder = folderData;
        renderPage();
      });

      const contentContainer = document.getElementById("content-container");
      const desktopMediaQuery = window.matchMedia("(min-width: 768px)");

      // Hamburger menu logic
      document.addEventListener("DOMContentLoaded", function () {
        const hamburgerBtn = document.getElementById("hamburger-btn");
        const mobileNavOverlay = document.getElementById("mobile-nav-overlay");
        const closeMobileNav = document.getElementById("close-mobile-nav");
        const mobileNavLinks = mobileNavOverlay.querySelectorAll("a");

        hamburgerBtn.addEventListener("click", () => {
          mobileNavOverlay.classList.remove("hidden");
        });

        closeMobileNav.addEventListener("click", () => {
          mobileNavOverlay.classList.add("hidden");
        });

        // Close overlay when a link is clicked
        mobileNavLinks.forEach((link) => {
          link.addEventListener("click", () => {
            mobileNavOverlay.classList.add("hidden");
          });
        });
      });

    function getImageSrc(filename) {
        // Use window.location.hostname to detect environment
        const isDev = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
        if (isDev) {
            return `/img/${filename}`;
        } else {
            return `https://res.cloudinary.com/dg7vg50i9/image/upload/f_auto,q_auto/${filename}`;
        }
    }

    function renderTree(node) {
        if (!node) return "";

        // cross-reference folder.json for source arrays
        if(node.source){
          node.children = window.folder.flat[node.source]?.map(img => ({
            type: "img",
            src: `${node.source}/${img}`,
            alt: img,
          })) || [];
        }

        // fallbacks for missing type
        if(node.type === undefined){
          node.type = "div";
        }

        // Handle text nodes
        if (node.type === "text") {
          return node.content || "";
        }
        // If description is present, insert it as a styled div after the first child
        if(node.meta){
          node?.children?.splice(1, 0, {
            type: "div",
            class: "m-[20px] text-2xl font-eb-garamond text-black mx-auto text-left max-w-[70%]",
            content: node.meta
          });
        }

        // Build props string
        let propsArr = [];

        // For non-image nodes, add common attributes like href
        // (Assuming properties not in a reserved list belong as attributes)
        const reserved = ["type", "children", "content", "class", "style", "src", "alt", "meta", "caption", "captionStyle", "linkTo", "source"];
        Object.keys(node).forEach((key) => {
          if (!reserved.includes(key) && typeof node[key] === "string") {
            propsArr.push(`${key}="${node[key]}"`);
          }
        });

        // Handle images
        if(node.type === "img") {
          // Build the image props
          let imgProps = [];
          if(node.src){
            if(typeof node.src === "string"){
              imgProps.push(`src="${getImageSrc(node.src)}"`);
            } else if(Array.isArray(node.src)){
              let randomSrc = node.src[Math.floor(Math.random() * node.src.length)];
              imgProps.push(`src="${getImageSrc(randomSrc)}"`);
            }
          } else {
            console.warn("Image node missing 'src' property:", node);
          }
          if(node.alt){
            imgProps.push(`alt="${node.alt}"`);
          }
          if(node.class) {
            imgProps.push(`class="${node.class}"`);
          }
          // Add native lazy-loading to load images only when close to viewport:
          imgProps.push(`loading="lazy"`);
          // Build common attributes from node
          const reserved = ["type", "children", "content", "class", "style", "src", "alt", "caption", "captionStyle"];
          Object.keys(node).forEach(key => {
            if(!reserved.includes(key) && typeof node[key] === "string"){
              imgProps.push(`${key}="${node[key]}"`);
            }
          });
          
          let imageHTML = "";
          // If a caption is provided, wrap the image in a <figure>
          if(node.caption) {
            let figCaptionProps = node.captionStyle ? ` class="${node.captionStyle}"` : "";
            imageHTML = `<figure>
              <img ${imgProps.join(" ")}/>
              <figcaption${figCaptionProps}>${node.caption}</figcaption>
            </figure>`;
          } else {
            // No caption? Render just the image as self-closing
            imageHTML = `<img ${imgProps.join(" ")}/>`;
          }
          // If linkTo is provided, wrap the whole structure in an anchor.
          if (node.linkTo) {
            imageHTML = `<a href="/${node.linkTo}">${imageHTML}</a>`;
          }

          return imageHTML;
        }

        // Handle class
        if (node.class) {
          propsArr.push(`class="${node.class}"`);
        }

        // Handle style (choose desktop or mobile)
        let styleObj = {};
        if (node.style) {
          const isDesktop = window.matchMedia("(min-width: 768px)").matches;
          if (node.style.desktop || node.style.mobile) {
            styleObj = isDesktop
              ? node.style.desktop || {}
              : node.style.mobile || {};
          } else {
            styleObj = node.style;
          }
        }
        // If textColor is present, add it to style
        if (node.textColor) {
          styleObj = { ...styleObj, color: node.textColor };
        }
        const styleStr = Object.entries(styleObj)
          .map(([k, v]) => `${k}:${v}`)
          .join(";");
        if (styleStr) {
          propsArr.push(`style="${styleStr}"`);
        }

        const propsStr = propsArr.length ? " " + propsArr.join(" ") : "";

        // Children
        let childrenStr = "";
        if (node.children && Array.isArray(node.children)) {
          childrenStr = node.children.map(renderTree).join("");
        }

        // Self-closing tags
        const selfClosing = ["img", "br", "hr", "input", "meta", "link"];
        if (selfClosing.includes(node.type)) {
          return `<${node.type}${propsStr}/>`;
        }

        // Normal tags
        return `<${node.type}${propsStr}>${node.content || ""}${childrenStr}</${
          node.type
        }>`;
      }

      /**
       * Renders the page content based on the current URL hash.
       */
      function renderPage() {

        if(!window.manifest) {
          console.warn("Manifest not loaded yet.");
          return;
        }

          const fullPath = window.location.pathname;
          let currentSlug = fullPath === "/" ? "" : fullPath.slice(1);

          // Try to find an exact match first.
          let currentPage = manifest.pages.find(page => page.slug === currentSlug);

          // If not found and there are subroutes, try to fall back to a parent route.
          if (!currentPage && currentSlug.includes("/")) {
            const segments = currentSlug.split("/");
            while (segments.length > 0 && !currentPage) {
              const routeToCheck = segments.join("/");
              currentPage = manifest.pages.find(page => page.slug === routeToCheck);
              segments.pop();
            }
          }

          // If still not found, redirect to home.
          if (!currentPage) {
            history.replaceState({}, "", "/");
            renderPage();
            return;
          }


        contentContainer.innerHTML = "";
        contentContainer.className = "relative w-full min-h-screen";

        if (currentPage.background) {
          contentContainer.style.backgroundImage = `url(${getImageSrc(currentPage.background)})`;
          contentContainer.style.backgroundSize = "cover";
          contentContainer.style.backgroundPosition = "center";
          contentContainer.style.backgroundAttachment = "fixed";
        } else {
          contentContainer.style.backgroundImage = "";
        }

        // Nav color logic
        const navLinks = document.querySelectorAll("#nav-links a");
        const logo = document.querySelectorAll("#logo a")[0];
        const hamburgerBtn = document.getElementById("hamburger-btn");
        const closeMobileNav = document.getElementById("close-mobile-nav");

        navLinks.forEach((link) => {
          // Reset color and underline
          link.style.color = "";
          link.style.textDecoration = "";
          // Get slug from href
          const linkSlug = link.getAttribute("href").slice(1); 
          // If navColor is set, apply it
          if (currentPage.navColor) {
            link.style.color = currentPage.navColor;
            logo.style.color = currentPage.navColor;
            hamburgerBtn.style.color = currentPage.navColor;
            closeMobileNav.style.color = currentPage.navColor;
          } else {
            link.style.color = "";
            logo.style.color = "";
            hamburgerBtn.style.color = "";
            closeMobileNav.style.color = "";
          }
          // Underline active link
          if (linkSlug === currentSlug) {
            link.style.textDecoration = "underline";
          }
        });

        // Render the tree recursively
        contentContainer.innerHTML = renderTree(currentPage.tree);
      }

      // Hook into History API for navigation:
      document.addEventListener("click", function(e) {
        const target = e.target.closest("a");
        if (!target) return;
        const href = target.getAttribute("href");
        if (href && href.startsWith("/")) { // internal link
          e.preventDefault();
          history.pushState({}, "", href);
          renderPage();
        }
      });

      // Listen for browser back/forward events:
      window.addEventListener("popstate", renderPage);

      // Initial rendering:
      document.addEventListener("DOMContentLoaded", renderPage);
      
    </script>


    <footer class="text-center p-4 bg-black text-white text-opacity-30">
      <a target="_blank" href="https://pothattila.substack.com/">Blog </a> ◦
      <a target="_blank" href="https://pothattila.hu/">Travel </a> ◦
      &copy; 2025 Póth Attila. 
      <a href="/sitemap">♠ </a>
    </footer>

  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://use.typekit.net/bne3zga.css">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <style>
      body {
        font-optical-sizing: auto;
        font-style: normal;
        background-color: white;
        overflow-y: auto;
      }
      /* prevent layout loading from anchoring scroll (avoid jumps when images load) */
      #content-container {
        overflow-anchor: none;
      }
      h1 {
        font-size: 3rem;
        line-height: 1.1;
        margin-bottom: 1rem;
      }
      img {
        margin: 0 auto;
        opacity: 0;
        animation: fadeIn 1s ease-in-out forwards;
      }

      .first-img-cover > img:first-of-type,
      .first-img-cover > figure:first-of-type > img {
        width: 100%;
        min-height: 100vh;
        object-fit: cover;
      }

      /* Define the fade-in keyframe animation */
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .masonry-container {
        margin: 20px;
        column-count: 2;
        column-gap: 1rem;
      }
      @media (min-width: 768px) {
        .masonry-container {
          column-count: 4;
        }
        .masonry-container.masonry-2 { column-count: 2; }
        .masonry-container.masonry-3 { column-count: 3; }
        .masonry-container.masonry-4 { column-count: 4; }
        .masonry-container.masonry-6 { column-count: 5; }
      }
      .masonry-container img {
        width: 100%;
        display: block;
        margin-bottom: 1rem;
        break-inside: avoid;
      }
      figure {
        position: relative;
      }
      figure figcaption {
        position: absolute;
        bottom: 15px;
        width: 100%;
        margin: 0;
        font-size: 2rem;
        text-align: center;
        color: white;
      }
      figure figcaption.caption-center {
        left: 50%;
        bottom: 50%;
        transform: translate(-50%, 50%);
      }
      @media (max-width: 767px) {
        figure figcaption {
          font-size: 1.5rem; 
        }
      }
      main img {
        margin-bottom: 0.5rem;
      }

      div.sidescroll-gallery {
        height: 100vh; 
        display: flex; 
        overflow-x: auto;
        gap: 1rem;
        scroll-snap-type: x mandatory;  /* Optional: enables snap scrolling */
        -webkit-overflow-scrolling: touch; /* For smooth scrolling on iOS */
        scrollbar-width: none;     /* For Firefox */
      }
      div.sidescroll-gallery img {
        height: 100vh;
        width: auto;        /* let width scale naturally (keeping aspect ratio) */
        max-width: none;    /* prevent max-width skewing images */
        flex-shrink: 0;     /* prevent images from shrinking */
        scroll-snap-align: start; 
      }
      div.sidescroll-gallery div {
        min-width: 300px;
        height: 100vh;
        padding-top: 88px;
        box-sizing: border-box;
      }
      div.sidescroll-gallery::-webkit-scrollbar {
        display: none;   /* For Chrome, Safari, Opera */
      }
    </style>
  </head>
  <body class="relative min-h-screen">
    <!-- Navigation Menu -->
    <nav class="absolute top-0 left-0 w-full z-10 p-4 bg-transparent">
      <div
        id="logo"
        class="container mx-auto flex justify-between items-center px-4 md:px-0"
      >
        <a
          href="/"
          id="logo-link"
          class="font-ambroise text-4xl font-bold text-white rounded-md p-2"
        >
          <!-- manifest.logo will be injected -->
        </a>
        <!-- Hamburger button (shown on mobile) -->
        <button
          id="hamburger-btn"
          class="md:hidden text-white text-5xl focus:outline-none"
          aria-label="Open menu"
        >
          &equiv;
        </button>
        <!-- Desktop nav links -->
        <div class="space-x-4 hidden md:block" id="nav-links"></div>
      </div>
      <!-- Mobile overlay menu -->
      <div
        id="mobile-nav-overlay"
        class="fixed inset-0 bg-black bg-opacity-90 flex flex-col justify-center items-center z-50 hidden"
      >
        <button
          id="close-mobile-nav"
          class="absolute top-6 right-8 text-white text-4xl"
        >
          &#10005;
        </button>
        <nav id="mobile-nav-list" class="flex flex-col space-y-8 text-center text-3xl font-bold"></nav>
      </div>
    </nav>

    <!-- Main content container -->
    <main id="content-container" class="relative w-full h-screen">
      <!-- Content will be dynamically injected here -->
    </main>

    <script>

      const isDev = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
      let GA_TRACKING_ID = null; // will be set from manifest.meta.ga if present

      // Function to track a pageview for the new route
      function trackPageView(path, title) {
        if (typeof gtag === 'function') {
          gtag('event', 'page_view', {
            page_title: title,
            page_path: path,
            send_to: GA_TRACKING_ID
          });
          console.log(`GA: Path=${path}, Title=${title}`);
        }
      }

      function submitForm(formElem, intent) {
        // formElem may be the <form> element passed from manifest action
        try {
          const fd = new FormData(formElem);
          const payload = { intent };
          fd.forEach((v, k) => { payload[k] = v; });

          fetch('/form', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          })
          .then(res => {
            if (res.ok) {
              formElem.reset();
            } else {
              console.warn('Sorry, something went wrong at /', intent);
            }
          })
          .catch(() => console.error('Network error — please try again.'));
        } catch (err) {
          console.error('submitForm error', err);
        }
      }

      /* prevent layout loading from anchoring scroll (avoid jumps when images load) */
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }

      function scrollToTopNow() {
        // reset scrolling on document and the main container
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
        const container = document.getElementById('content-container');
        if (container) container.scrollTop = 0;
        // double rAF to ensure after paint/layout
        requestAnimationFrame(() => requestAnimationFrame(() => window.scrollTo(0, 0)));
      }

      fetch('/api/manifest')
        .then(res => {
          if (!res.ok) throw new Error('Failed to load manifest');
          return res.json();
        })
        .then(manifestData => {
          // server returned merged manifest and included raw folder as _folder
          window.manifest = manifestData;

          // set document title from manifest.meta.title (if present)
          if (manifestData.meta && manifestData.meta.title) {
            document.title = manifestData.meta.title;
          }
          // set logo (text or simple HTML) from manifest.meta.logo
          const logoLink = document.getElementById('logo-link');
          if (logoLink) {
            const logoContent = (manifestData.meta && manifestData.meta.logo) ? manifestData.meta.logo : '';
            logoLink.innerHTML = logoContent;
          }

          // build nav links (desktop and mobile) from manifest.nav
          const buildNav = (navArray) => {
            const desktop = document.getElementById('nav-links');
            const mobile = document.getElementById('mobile-nav-list');
            if (desktop) desktop.innerHTML = '';
            if (mobile) mobile.innerHTML = '';
            (navArray || []).forEach(item => {
              const a = document.createElement('a');
              a.href = item.href || '/';
              a.textContent = item.label || item.href;
              a.className = 'px-2';
              if (desktop) desktop.appendChild(a);
              const am = a.cloneNode(true);
              if (mobile) mobile.appendChild(am);
            });
          };
          if (manifestData.nav) buildNav(manifestData.nav);

          // attach mobile nav handlers again in case nav was built after DOMContentLoaded
          (function setupMobileHandlers(){
            const hamburgerBtn = document.getElementById("hamburger-btn");
            const mobileNavOverlay = document.getElementById("mobile-nav-overlay");
            const closeMobileNav = document.getElementById("close-mobile-nav");
            const mobileNavLinks = mobileNavOverlay.querySelectorAll("a");
            if (hamburgerBtn && mobileNavOverlay) {
              hamburgerBtn.addEventListener("click", () => mobileNavOverlay.classList.remove("hidden"));
            }
            if (closeMobileNav && mobileNavOverlay) {
              closeMobileNav.addEventListener("click", () => mobileNavOverlay.classList.add("hidden"));
            }
            mobileNavLinks.forEach((link) => {
              link.addEventListener("click", () => mobileNavOverlay.classList.add("hidden"));
            });
          })();

          // dynamically load Google Analytics if provided
          if (manifestData.meta && manifestData.meta.ga) {
            GA_TRACKING_ID = manifestData.meta.ga;
            // inject gtag script
            const gtagScript = document.createElement('script');
            gtagScript.async = true;
            gtagScript.src = `https://www.googletagmanager.com/gtag/js?id=${GA_TRACKING_ID}`;
            document.head.appendChild(gtagScript);
            // inject initialization
            const inline = document.createElement('script');
            inline.text = `
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', '${GA_TRACKING_ID}');
            `;
            document.head.appendChild(inline);
          }

          // inject project-specific CSS files
          (manifest.css || []).forEach(href => {
            const l = document.createElement('link');
            l.rel = 'stylesheet';
            l.href = href;
            document.head.appendChild(l);
          });
          // inject font stylesheet links (e.g. Google Fonts)
          (manifest.fonts || []).forEach(href => {
            const l = document.createElement('link');
            l.rel = 'stylesheet';
            l.href = href;
            document.head.appendChild(l);
          });
          // render DOM
          renderPage();
        })
        .catch(err => {
          console.error('Error loading manifest:', err);
        });

      const contentContainer = document.getElementById("content-container");
      const desktopMediaQuery = window.matchMedia("(min-width: 768px)");


    function getImageSrc(filename) {
        // Use window.location.hostname to detect environment
        if (isDev) {
            return `/img/${filename}`;
        } else {
            return `https://res.cloudinary.com/dg7vg50i9/image/upload/f_auto,q_auto/${filename}`;
        }
    }

    function renderTree(node) {
        if (!node) return "";

        // cross-reference folder.json for source arrays
        if(node.source){
          node.children = window?.manifest?._folder?.flat[node.source]
          ?.map(img => ({
            type: "img",
            src: `${node.source}/${img}`,
            alt: img,
          }))
          // shuffle the array
          .map(value => ({ value, sort: Math.random() }))
          .sort((a, b) => a.sort - b.sort)
          .map(({ value }) => value)  || [];
        }

        // fallbacks for missing type
        if(node.type === undefined){
          node.type = "div";
        }

        // Handle text nodes
        if (node.type === "text") {
          return node.content || "";
        }
        // If description is present, insert it as a styled div after the first child
        if(node.meta){
          node?.children?.splice(1, 0, {
            type: "div",
            class: "m-[20px] text-2xl font-eb-garamond text-black mx-auto text-left max-w-[70%]",
            content: node.meta
          });
        }

        if (node.type === "background") {
          // Use getImageSrc on the source
          const bgImage = getImageSrc(node.src);
          // Allow inline styles to be overridden via the class if needed.
          let extraStyle = `background-image: url(${bgImage}); background-size: cover; background-position: center;`;
          // If desired, you can append default dimensions.
          extraStyle += "width: 100%; height: 100vh;";
          
          // Build props from node.class and inline style
          const classProp = node.class ? ` class="${node.class}"` : "";
          const styleProp = ` style="${extraStyle}"`;
          
          // Render children as inner HTML
          let childrenStr = "";
          if (node.children && Array.isArray(node.children)) {
            childrenStr = node.children.map(renderTree).join("");
          }
          
          return `<div${classProp}${styleProp}>${node.content || ""}${childrenStr}</div>`;
        }

        // Build props string
        let propsArr = [];

        // For non-image nodes, add common attributes like href
        // (Assuming properties not in a reserved list belong as attributes)
        const reserved = ["type", "children", "content", "class", "style", "src", "alt", "meta", "caption", "captionStyle", "linkTo", "source"];
        Object.keys(node).forEach((key) => {
          if (!reserved.includes(key) && typeof node[key] === "string") {
            propsArr.push(`${key}="${node[key]}"`);
          }
        });

        // Handle images
        if(node.type === "img") {
          // Build the image props
          let imgProps = [];
          if(node.src){
            if(typeof node.src === "string"){
              imgProps.push(`src="${getImageSrc(node.src)}"`);
            } else if(Array.isArray(node.src)){
              let randomSrc = node.src[Math.floor(Math.random() * node.src.length)];
              imgProps.push(`src="${getImageSrc(randomSrc)}"`);
            }
          } else {
            console.warn("Image node missing 'src' property:", node);
          }
          if(node.alt){
            imgProps.push(`alt="${node.alt}"`);
          }
          if(node.class) {
            imgProps.push(`class="${node.class}"`);
          }
          // Add native lazy-loading to load images only when close to viewport:
          imgProps.push(`loading="lazy"`);
          // Build common attributes from node
          const reserved = ["type", "children", "content", "class", "style", "src", "alt", "caption", "captionStyle"];
          Object.keys(node).forEach(key => {
            if(!reserved.includes(key) && typeof node[key] === "string"){
              imgProps.push(`${key}="${node[key]}"`);
            }
          });
          
          let imageHTML = "";
          // If a caption is provided, wrap the image in a <figure>
          if(node.caption) {
            let figCaptionProps = node.captionStyle ? ` class="${node.captionStyle}"` : "";
            imageHTML = `<figure>
              <img ${imgProps.join(" ")}/>
              <figcaption${figCaptionProps}>${node.caption}</figcaption>
            </figure>`;
          } else {
            // No caption? Render just the image as self-closing
            imageHTML = `<img ${imgProps.join(" ")}/>`;
          }
          // If linkTo is provided, wrap the whole structure in an anchor.
          if (node.linkTo) {
            imageHTML = `<a href="/${node.linkTo}">${imageHTML}</a>`;
          }

          return imageHTML;
        }

        // Handle class
        if (node.class) {
          propsArr.push(`class="${node.class}"`);
        }

        // Handle style (choose desktop or mobile)
        let styleObj = {};
        if (node.style) {
          const isDesktop = window.matchMedia("(min-width: 768px)").matches;
          if (node.style.desktop || node.style.mobile) {
            styleObj = isDesktop
              ? node.style.desktop || {}
              : node.style.mobile || {};
          } else {
            styleObj = node.style;
          }
        }
        // If textColor is present, add it to style
        if (node.textColor) {
          styleObj = { ...styleObj, color: node.textColor };
        }
        const styleStr = Object.entries(styleObj)
          .map(([k, v]) => `${k}:${v}`)
          .join(";");
        if (styleStr) {
          propsArr.push(`style="${styleStr}"`);
        }

        const propsStr = propsArr.length ? " " + propsArr.join(" ") : "";

        // Children
        let childrenStr = "";
        if (node.children && Array.isArray(node.children)) {
          childrenStr = node.children.map(renderTree).join("");
        }

        // Self-closing tags
        const selfClosing = ["img", "br", "hr", "input", "meta", "link"];
        if (selfClosing.includes(node.type)) {
          return `<${node.type}${propsStr}/>`;
        }

        // Normal tags
        return `<${node.type}${propsStr}>${node.content || ""}${childrenStr}</${
          node.type
        }>`;
      }

      /**
       * Renders the page content based on the current URL hash.
       */
      function renderPage() {

        if(!window.manifest) {
          console.warn("Manifest not loaded yet.");
          return;
        }

          const fullPath = window.location.pathname;
          let currentSlug = fullPath === "/" ? "" : fullPath.slice(1);

          // Try to find an exact match first.
          let currentPage = manifest.pages.find(page => page.slug === currentSlug);

          // If not found and there are subroutes, try to fall back to a parent route.
          if (!currentPage && currentSlug.includes("/")) {
            const segments = currentSlug.split("/");
            while (segments.length > 0 && !currentPage) {
              const routeToCheck = segments.join("/");
              currentPage = manifest.pages.find(page => page.slug === routeToCheck);
              segments.pop();
            }
          }

          // If still not found, redirect to home.
          if (!currentPage) {
            history.replaceState({}, "", "/");
            renderPage();
            return;
          }


        contentContainer.innerHTML = "";
        contentContainer.className = "relative w-full min-h-screen";

        if (currentPage.background) {
          contentContainer.style.backgroundImage = `url(${getImageSrc(currentPage.background)})`;
          contentContainer.style.backgroundSize = "cover";
          contentContainer.style.backgroundPosition = "center";
          contentContainer.style.backgroundAttachment = "fixed";
        } else {
          contentContainer.style.backgroundImage = "";
        }

        // Nav color logic
        const navLinks = document.querySelectorAll("#nav-links a");
        const logo = document.querySelectorAll("#logo a")[0];
        const hamburgerBtn = document.getElementById("hamburger-btn");
        const closeMobileNav = document.getElementById("close-mobile-nav");

        navLinks.forEach((link) => {
          // Reset color and underline
          link.style.color = "";
          link.style.textDecoration = "";
          // Get slug from href
          const linkSlug = link.getAttribute("href").slice(1); 
          // If navColor is set, apply it
          if (currentPage.navColor) {
            link.style.color = currentPage.navColor;
            logo.style.color = currentPage.navColor;
            hamburgerBtn.style.color = currentPage.navColor;
            closeMobileNav.style.color = currentPage.navColor;
          } else {
            link.style.color = "";
            logo.style.color = "";
            hamburgerBtn.style.color = "";
            closeMobileNav.style.color = "";
          }
          // Underline active link
          if (linkSlug === currentSlug) {
            link.style.textDecoration = "underline";
          }
        });

        // Render the tree recursively
        contentContainer.innerHTML = renderTree(currentPage.tree);
        // force initial scroll to top immediately after injecting content
        scrollToTopNow();
      }

      // Hook into History API for navigation:
      document.addEventListener("click", function(e) {
        const target = e.target.closest("a");
        if (!target) return;
        const href = target.getAttribute("href");
        if (href && href.startsWith("/")) { // internal link
          e.preventDefault();
          history.pushState({}, "", href);
          if(!isDev) {
            trackPageView(href, href);
          }
          renderPage();
        }
      });

      // Listen for browser back/forward events:
      window.addEventListener("popstate", renderPage);

      // Initial rendering:
      document.addEventListener("DOMContentLoaded", renderPage);
      
    </script>


    <footer class="text-center p-4 bg-black text-white text-opacity-30">
      <a target="_blank" href="https://pothattila.substack.com/">Blog </a> ◦
      <a target="_blank" href="https://pothattila.hu/">Travel </a> ◦
      &copy; 2025 Póth Attila. 
      <a href="/sitemap">♠ </a>
    </footer>

  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Photography Portfolio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://use.typekit.net/bne3zga.css">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <!--link
      href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap"
      rel="stylesheet"
    /-->
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <!-- link href="https://fonts.cdnfonts.com/css/modernline-personal-use" rel="stylesheet" -->
    <link href="https://fonts.cdnfonts.com/css/reenie-beanie" rel="stylesheet">
                
    <style>
      /*
        Ambroise Std Regular
            font-family: "ambroise-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Italic
            font-family: "ambroise-std", serif;
            font-weight: 400;
            font-style: italic;
        Ambroise Std Bold
            font-family: "ambroise-std", serif;
            font-weight: 700;
            font-style: normal;
        Ambroise Std Bold Italic
            font-family: "ambroise-std", serif;
            font-weight: 700;
            font-style: italic;
        Ambroise Std Firmin Regular
            font-family: "ambroise-firmin-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Firmin Bold
            font-family: "ambroise-firmin-std", serif;
            font-weight: 700;
            font-style: normal;
        Ambroise Std Francois Regular
            font-family: "ambroise-francois-std", serif;
            font-weight: 400;
            font-style: normal;
        Ambroise Std Francois Bold
            font-family: "ambroise-francois-std", serif;
            font-weight: 700;
            font-style: normal;
      */
      body {
        font-family: "Josefin Sans", sans-serif;
        font-optical-sizing: auto;
        letter-spacing: -0.05em;
        font-weight: 700;
        font-style: normal;
        background-color: white;
        color: #f5f5f5;
        overflow-y: auto;
      }
      .font-eb-garamond {
        font-family: "EB Garamond", serif;
        font-optical-sizing: auto;
        font-weight: 400;
        font-style: normal;
      }
      .font-josefin-sans {
        font-family: "Josefin Sans", sans-serif;
        font-optical-sizing: auto;
        font-weight: 100;
        font-style: normal;
      }
      .font-ambroise {
        font-family: "ambroise-firmin-std", serif;
        font-style: normal;
        font-weight: 400;
      }
      .font-modernline {
        font-family: 'modernline - Personal Use', sans-serif;
        font-style: normal;
        font-weight: 100;
      }
      .font-reenie {
        font-family: 'Reenie Beanie', sans-serif;
        font-style: normal;
        font-weight: 100;
      }
      .masonry-container {
        margin: 80px 0 0 0;
        column-count: 2;
        column-gap: 1rem;
      }
      @media (min-width: 768px) {
        .masonry-container {
          column-count: 4;
        }
      }
      .masonry-container img {
        width: 100%;
        display: block;
        margin-bottom: 1rem;
        break-inside: avoid;
      }
      figure {
        position: relative;
      }
      figure figcaption {
        position: absolute;
        bottom: 15px;
        right: 15px;
        margin: 0;
        font-size: 1.5rem;
        text-align: center;
        color: white;
      }
      @media (max-width: 767px) {
        figure figcaption {
          font-size: 1rem; 
        }
      }
    </style>
  </head>
  <body class="relative min-h-screen">
    <!-- Navigation Menu -->
    <nav class="fixed top-0 left-0 w-full z-10 p-4 bg-transparent">
      <div
        id="logo"
        class="container mx-auto flex justify-between items-center px-4 md:px-0"
      >
        <a
          href="#"
          class="ambroise text-4xl font-bold text-white rounded-md p-2 hover:bg-white/10 transition-colors"
        >
          PÃ³th Attila
        </a>
        <!-- Hamburger button (shown on mobile) -->
        <button
          id="hamburger-btn"
          class="md:hidden text-white text-5xl focus:outline-none"
          aria-label="Open menu"
        >
          &equiv;
        </button>
        <!-- Desktop nav links -->
        <div class="space-x-4 hidden md:block" id="nav-links">
          <a href="#fashion">Fashion</a>
          <a href="#analog">Analog</a>
          <a href="#collabs">Collabs</a>
          <a href="#backstage">Backstage</a>
          <a href="#projects">Projects</a>
          <a href="#about">About</a>
        </div>
      </div>
      <!-- Mobile overlay menu -->
      <div
        id="mobile-nav-overlay"
        class="fixed inset-0 bg-black bg-opacity-90 flex flex-col justify-center items-center z-50 hidden"
      >
        <button
          id="close-mobile-nav"
          class="absolute top-6 right-8 text-white text-4xl"
        >
          &#10005;
        </button>
        <nav class="flex flex-col space-y-8 text-center text-3xl font-bold">
          <a href="#fashion">Fashion</a>
          <a href="#analog">Analog</a>
          <a href="#collabs">Collabs</a>
          <a href="#backstage">Backstage</a>
          <a href="#projects">Projects</a>
          <a href="#about">About</a>
        </nav>
      </div>
    </nav>

    <!-- Main content container -->
    <main id="content-container" class="relative w-full h-screen">
      <!-- Content will be dynamically injected here -->
    </main>

    <script>
      const apis = Promise.all([
        fetch("manifest.json"),
        fetch("folder.json"),
      ]).then(([manifestRes, folderRes]) =>
        Promise.all([manifestRes.json(), folderRes.json()])
      ).then(([manifestData, folderData]) => {

        Object.keys(folderData.flat).forEach(route => {
          const existingPage = manifestData.pages.find(page => page.slug === route);
          if (existingPage) return; // Skip if page already exists
          manifestData.pages.push({
            slug: route,
            tree: {
              source: route
            }
          });
        });
        manifestData.pages.push({
          "slug": "sitemap",
          "navColor": "black",
          "tree": {
            "type": "div",
            "class": "min-h-screen flex flex-col items-center justify-center space-y-4 p-8",
            "children": Object.keys(folderData.flat).map(route => ({
              type: "a",
              href: `#${route}`,
              class: "text-2xl md:text-4xl font-bold text-black p-4 rounded-md",
              content: route
            }))
          }
        });

        window.manifest = manifestData;
        window.folder = folderData;
        renderPage();
      });

      const contentContainer = document.getElementById("content-container");
      const desktopMediaQuery = window.matchMedia("(min-width: 768px)");

      // Hamburger menu logic
      document.addEventListener("DOMContentLoaded", function () {
        const hamburgerBtn = document.getElementById("hamburger-btn");
        const mobileNavOverlay = document.getElementById("mobile-nav-overlay");
        const closeMobileNav = document.getElementById("close-mobile-nav");
        const mobileNavLinks = mobileNavOverlay.querySelectorAll("a");

        hamburgerBtn.addEventListener("click", () => {
          mobileNavOverlay.classList.remove("hidden");
        });

        closeMobileNav.addEventListener("click", () => {
          mobileNavOverlay.classList.add("hidden");
        });

        // Close overlay when a link is clicked
        mobileNavLinks.forEach((link) => {
          link.addEventListener("click", () => {
            mobileNavOverlay.classList.add("hidden");
          });
        });
      });

    function getImageSrc(filename) {
        // Use window.location.hostname to detect environment
        const isDev = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
        if (isDev) {
            return `/img/${filename}`;
        } else {
            return `https://res.cloudinary.com/dg7vg50i9/image/upload/f_auto,q_auto/v1756910837/${filename}`;
        }
    }

    function renderTree(node) {
        if (!node) return "";

        // cross-reference folder.json for source arrays
        if(node.source){
          node.children = window.folder.flat[node.source]?.map(img => ({
            type: "img",
            src: `${node.source}/${img}`,
            alt: img,
          })) || [];
        }

        // fallbacks for missing type
        if(node.type === undefined){
          node.type = "div";
        }

        // Handle text nodes
        if (node.type === "text") {
          return node.content || "";
        }

        // Build props string
        let propsArr = [];

        // For non-image nodes, add common attributes like href
        // (Assuming properties not in a reserved list belong as attributes)
        const reserved = ["type", "children", "content", "class", "style", "src", "alt"];
        Object.keys(node).forEach((key) => {
          if (!reserved.includes(key) && typeof node[key] === "string") {
            propsArr.push(`${key}="${node[key]}"`);
          }
        });

        // Handle images
        if(node.type === "img") {
          // Build the image props
          let imgProps = [];
          if(node.src){
            if(typeof node.src === "string"){
              imgProps.push(`src="${getImageSrc(node.src)}"`);
            } else if(Array.isArray(node.src)){
              let randomSrc = node.src[Math.floor(Math.random() * node.src.length)];
              imgProps.push(`src="${getImageSrc(randomSrc)}"`);
            }
          } else {
            console.warn("Image node missing 'src' property:", node);
          }
          if(node.alt){
            imgProps.push(`alt="${node.alt}"`);
          } else {
            imgProps.push(`alt="${node.src}"`);
          }
          if(node.class) {
            imgProps.push(`class="${node.class}"`);
          }
          // Build common attributes from node
          const reserved = ["type", "children", "content", "class", "style", "src", "alt", "caption", "captionStyle"];
          Object.keys(node).forEach(key => {
            if(!reserved.includes(key) && typeof node[key] === "string"){
              imgProps.push(`${key}="${node[key]}"`);
            }
          });
          
          // If a caption is provided, wrap the image in a <figure>
          if(node.caption) {
            let figCaptionProps = node.captionStyle ? ` class="${node.captionStyle}"` : "";
            return `<figure>
              <img ${imgProps.join(" ")}/>
              <figcaption${figCaptionProps}>${node.caption}</figcaption>
            </figure>`;
          } else {
            // No caption? Render just the image as self-closing
            return `<img ${imgProps.join(" ")}/>`;
          }
        }

        // Handle class
        if (node.class) {
          propsArr.push(`class="${node.class}"`);
        }

        // Handle style (choose desktop or mobile)
        let styleObj = {};
        if (node.style) {
          const isDesktop = window.matchMedia("(min-width: 768px)").matches;
          if (node.style.desktop || node.style.mobile) {
            styleObj = isDesktop
              ? node.style.desktop || {}
              : node.style.mobile || {};
          } else {
            styleObj = node.style;
          }
        }
        // If textColor is present, add it to style
        if (node.textColor) {
          styleObj = { ...styleObj, color: node.textColor };
        }
        const styleStr = Object.entries(styleObj)
          .map(([k, v]) => `${k}:${v}`)
          .join(";");
        if (styleStr) {
          propsArr.push(`style="${styleStr}"`);
        }

        const propsStr = propsArr.length ? " " + propsArr.join(" ") : "";

        // Children
        let childrenStr = "";
        if (node.children && Array.isArray(node.children)) {
          childrenStr = node.children.map(renderTree).join("");
        }

        // Self-closing tags
        const selfClosing = ["img", "br", "hr", "input", "meta", "link"];
        if (selfClosing.includes(node.type)) {
          return `<${node.type}${propsStr}/>`;
        }

        // Normal tags
        return `<${node.type}${propsStr}>${node.content || ""}${childrenStr}</${
          node.type
        }>`;
      }

      /**
       * Renders the page content based on the current URL hash.
       */
      function renderPage() {
        const currentSlug = window.location.hash.substring(1);
        const currentPage = manifest.pages.find(
          (page) => page.slug === currentSlug
        );

        if (!currentPage) {
          console.error("Page not found in manifest.");
          window.location.hash = "";
          return;
        }

        contentContainer.innerHTML = "";
        contentContainer.className = "relative w-full min-h-screen";

        if (currentPage.background) {
          contentContainer.style.backgroundImage = `url(${getImageSrc(currentPage.background)})`;
          contentContainer.style.backgroundSize = "cover";
          contentContainer.style.backgroundPosition = "center";
          contentContainer.style.backgroundAttachment = "fixed";
        } else {
          contentContainer.style.backgroundImage = "";
        }

        // Nav color logic
        const navLinks = document.querySelectorAll("#nav-links a");
        const logo = document.querySelectorAll("#logo a")[0];
        const hamburgerBtn = document.getElementById("hamburger-btn");
        const closeMobileNav = document.getElementById("close-mobile-nav");

        navLinks.forEach((link) => {
          // Reset color and underline
          link.style.color = "";
          link.style.textDecoration = "";
          // Get slug from href (after #)
          const linkSlug = link.getAttribute("href").replace("#", "");
          // If navColor is set, apply it
          if (currentPage.navColor) {
            link.style.color = currentPage.navColor;
            logo.style.color = currentPage.navColor;
            hamburgerBtn.style.color = currentPage.navColor;
            closeMobileNav.style.color = currentPage.navColor;
          } else {
            link.style.color = "";
            logo.style.color = "";
            hamburgerBtn.style.color = "";
            closeMobileNav.style.color = "";
          }
          // Underline active link
          if (linkSlug === currentSlug) {
            link.style.textDecoration = "underline";
          }
        });

        // Render the tree recursively
        contentContainer.innerHTML = renderTree(currentPage.tree);
      }

      // Add a listener for hash changes to enable routing
      window.addEventListener("hashchange", renderPage);

      // Initial render on page load
      //document.addEventListener('DOMContentLoaded', renderPage);

      // Re-render on media query change
      desktopMediaQuery.addListener(renderPage);
    </script>


    <footer class="text-center p-4 bg-white text-black">
      <a href="#sitemap" class="underline">Sitemap</a> |
      &copy; 2025 PÃ³th Attila. All rights reserved.
    </footer>

  </body>
</html>
